(function (global, factory) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define([], factory);
    } else {
        global.MomentumSlider = factory();
    }
}(this, function () {
    "use strict";

    function MomentumSlider(options) {
        this.o = extend({}, this.defaults, options);
        this.initHtml();
        this.initValues();
        this.initEvents();
        this.updateClassnames();
    }

    MomentumSlider.prototype = {
        defaults: {
            el: ".ms-container",
            cssClass: "",
            vertical: false,
            multiplier: 1,
            bounceCoefficient: 0.3,
            bounceMax: 100,
            loop: 0,
            interactive: true,
            reverse: false,
            currentIndex: 0
        },
        initHtml: function () {
            if (typeof this.o.el === "string") {
                this.msContainer = document.querySelector(this.o.el);
            } else {
                this.msContainer = this.o.el;
            }

            if (this.o.range) {
                let html = '<div class="ms-container ' + this.o.cssClass + '"><ul class="ms-track">';
                for (let i = this.o.range[0]; i <= this.o.range[1]; i++) {
                    html += typeof this.o.rangeContent === "function" ? wrapInLi(this.o.rangeContent(i)) : wrapInLi(i);
                }
                html += "</ul></div>";

                const container = document.createElement("div");
                container.innerHTML = html;
                this.msContainer.appendChild(container.firstChild);
                this.msContainer = this.msContainer.lastChild;
            }

            this.msContainer.classList.add("ms-container--" + (this.o.vertical ? "vertical" : "horizontal"));
            if (this.o.reverse) {
                this.msContainer.classList.add("ms-container--reverse");
            }

            this.msTrack = this.msContainer.children[0];
            this.msSlides = this.msTrack.children;
            this.step = this.o.vertical ? this.msSlides[0].scrollHeight : this.msSlides[0].scrollWidth;
            this.sliderLength = this.msSlides.length;

            if (this.o.loop) {
                let fragment = document.createDocumentFragment();
                for (let s = this.o.loop, n = this.sliderLength - s; s--;) {
                    fragment.appendChild(this.msSlides[n++].cloneNode(true));
                }
                this.msTrack.insertBefore(fragment, this.msTrack.firstChild);

                fragment = document.createDocumentFragment();
                for (let s = this.o.loop, n = 0; s--;) {
                    fragment.appendChild(this.msSlides[n++].cloneNode(true));
                }
                this.msTrack.appendChild(fragment);
                this.sliderLength += 2 * this.o.loop;
            }

            this.sliderWidth = this.sliderLength * this.step;
        },
        initValues: function () {
            this.boundMin = this.o.reverse ? 0 : -this.step * (this.sliderLength - 1);
            this.boundMax = this.o.reverse ? this.step * (this.sliderLength - 1) : 0;
            this.targetPosition = this.targetPosition || 0;
            this.ticking = false;
            this.enabled = true;
            this.pointerActive = false;
            this.pointerMoved = false;
            this.trackingPoints = [];
            this.msTrack.style[this.o.vertical ? "height" : "width"] = this.sliderWidth + "px";
            this.currentIndex = (this.currentIndex || this.o.currentIndex) + this.o.loop;
            this.updateSlider(undefined, true);
            this.renderTarget();

            for (let i = this.sliderLength; i--;) {
                this.setStyle(i, this.currentIndex === i ? 0 : -1);
            }
        },
        initEvents: function () {
            if (this.o.interactive) {
                this.msContainer.addEventListener("touchstart", this.onDown.bind(this));
                this.msContainer.addEventListener("mousedown", this.onDown.bind(this));
                document.addEventListener("touchmove", this.onMove.bind(this), supportsPassive() && { passive: false });
                document.addEventListener("touchend", this.onUp.bind(this));
                document.addEventListener("touchcancel", this.stopTracking.bind(this));
                document.addEventListener("mousemove", this.onMove.bind(this), supportsPassive() && { passive: false });
                document.addEventListener("mouseup", this.onUp.bind(this));
                
                if (this.o.prevEl) {
                    this.prevEl = typeof this.o.prevEl === "string" ? document.querySelector(this.o.prevEl) : this.o.prevEl;
                    this.prevEl.addEventListener("click", this.prev.bind(this));
                }

                if (this.o.nextEl) {
                    this.nextEl = typeof this.o.nextEl === "string" ? document.querySelector(this.o.nextEl) : this.o.nextEl;
                    this.nextEl.addEventListener("click", this.next.bind(this));
                }
            }

            window.addEventListener("resize", this.onResize.bind(this));
        },
        prev: function () {
            if (this.enabled) {
                this.updateSlider(Math.round(this.targetPosition / this.step) * this.step + (this.o.reverse ? -this.step : this.step));
            }
        },
        next: function () {
            if (this.enabled) {
                this.updateSlider(Math.round(this.targetPosition / this.step) * this.step + (this.o.reverse ? this.step : -this.step));
            }
        },
        select: function (index) {
            if (this.enabled) {
                this.updateSlider((index + this.o.loop) * (this.o.reverse ? this.step : -this.step));
            }
        },
        setStyleToNode: function (node, styles, progress, isForward) {
            if (styles) {
                let transform = "";
                for (let key in styles) {
                    if (key[0] === ".") {
                        this.setStyleToNode(node.querySelector(key), styles[key], progress, isForward);
                    } else if (key === "transform") {
                        styles[key].forEach(function (style) {
                            for (let prop in style) {
                                transform += prop + "(" + getCurrentValue(style[prop], progress, isForward);
                                if (prop === "rotate") transform += "deg";
                                if (["translateX", "translateY", "translateZ"].includes(prop)) transform += "px";
                                transform += ") ";
                            }
                        });
                    } else {
                        node.style[key] = getCurrentValue(styles[key], progress, isForward);
                    }
                }
                node.style.transform = transform;
            }
        },
        setStyle: function (index, progress, isForward) {
            this.setStyleToNode(this.msSlides[index], this.o.style, progress, isForward);
            if (typeof this.o.customStyles === "function") {
                this.o.customStyles(index, progress, isForward);
            }
        },
        renderTarget: function () {
            if (this.o.sync) {
                for (let syncItem of this.o.sync) {
                    syncItem.targetPosition = (syncItem.o.reverse ? -1 : 1) * this.targetPosition / this.sliderWidth * syncItem.sliderWidth;
                    syncItem.renderTarget();
                }
            }

            let loopOffset = this.o.loop * this.step;
            let loopWidth = this.sliderWidth - 2 * loopOffset;

            if (this.o.loop) {
                if (-this.targetPosition < loopOffset) {
                    while (-this.targetPosition < loopOffset) {
                        this.targetPosition -= loopWidth;
                    }
                } else if (-this.targetPosition >= loopOffset + loopWidth) {
                    while (-this.targetPosition >= loopOffset + loopWidth) {
                        this.targetPosition += loopWidth;
                    }
                }
            }

            let relativePosition = (this.o.reverse ? 1 : -1) * this.targetPosition / this.step;
            this.onChangeCurrentIndex(Math.round(relativePosition));

            let lowerIndex = Math.floor(relativePosition);
            let higherIndex = Math.ceil(relativePosition);
            let lowerProgress = relativePosition - lowerIndex;
            let higherProgress = relativePosition - higherIndex;

            if (this.lowerIndex !== undefined && this.lowerIndex !== lowerIndex && this.lowerIndex !== higherIndex) {
                this.setStyle(this.lowerIndex, 1, true);
            }
            if (this.higherIndex !== undefined && this.higherIndex !== lowerIndex && this.higherIndex !== higherIndex) {
                this.setStyle(this.higherIndex, -1);
            }

            if (lowerIndex >= 0 && lowerIndex < this.sliderLength) {
                this.setStyle(lowerIndex, lowerProgress, true);
                this.lowerIndex = lowerIndex;
            }
            if (higherIndex >= 0 && higherIndex < this.sliderLength) {
                this.setStyle(higherIndex, higherProgress);
                this.higherIndex = higherIndex;
            }

            this.msTrack.style[transformProperty] = `translate${this.o.vertical ? "Y" : "X"}(${this.targetPosition}px)`;
        },
        onDown: function (event) {
            if (this.enabled && (!this.pointerActive || event.pointerId === this.pointerId)) {
                event.preventDefault();
                this.pointerActive = true;
                this.pointerId = event.pointerId;
                this.pointerMoved = false;
                this.startPosition = this.getPointerPosition(event);
                this.lastPosition = this.startPosition;
                this.startTime = this.lastTime = performance.now();
                this.trackingPoints = [];
                this.ticking || this.updateLoop();
            }
        },
        onMove: function (event) {
            if (this.pointerActive && (!event.pointerId || event.pointerId === this.pointerId)) {
                event.preventDefault();
                this.pointerMoved = true;
                let currentPosition = this.getPointerPosition(event);
                this.targetPosition += currentPosition - this.lastPosition;
                this.lastPosition = currentPosition;
                this.lastTime = performance.now();
                this.trackPoint();
            }
        },
        onUp: function (event) {
            if (this.pointerActive && (!event.pointerId || event.pointerId === this.pointerId)) {
                this.pointerActive = false;
                if (this.pointerMoved) {
                    let momentum = this.calculateMomentum();
                    this.targetPosition += momentum.value;
                    this.bouncePosition(momentum);
                    this.updateLoop();
                }
            }
        },
        onResize: function () {
            this.initValues();
        },
        updateLoop: function () {
            this.ticking = true;
            requestAnimationFrame(() => {
                this.update();
                if (this.pointerActive || this.targetPosition !== this.previousPosition) {
                    this.updateLoop();
                } else {
                    this.ticking = false;
                }
            });
        },
        update: function () {
            this.previousPosition = this.targetPosition;
            this.renderTarget();
        },
        updateSlider: function (position, noAnim) {
            if (this.enabled) {
                this.targetPosition = position || this.targetPosition;
                if (noAnim) {
                    this.previousPosition = this.targetPosition;
                    this.renderTarget();
                } else {
                    this.updateLoop();
                }
            }
        },
        bouncePosition: function (momentum) {
            if (this.targetPosition < this.boundMin || this.targetPosition > this.boundMax) {
                let distance = this.targetPosition < this.boundMin ? this.targetPosition - this.boundMin : this.targetPosition - this.boundMax;
                this.targetPosition -= distance * (1 + this.o.bounceCoefficient);
                if (Math.abs(distance) > this.o.bounceMax) {
                    this.targetPosition = this.targetPosition < this.boundMin ? this.boundMin - this.o.bounceMax : this.boundMax + this.o.bounceMax;
                }
            }
        },
        calculateMomentum: function () {
            let velocity = this.getVelocity();
            return {
                value: velocity * this.o.multiplier,
                time: Math.abs(velocity / this.o.multiplier)
            };
        },
        getVelocity: function () {
            let lastPoint = this.trackingPoints[this.trackingPoints.length - 1];
            let firstPoint = this.trackingPoints[0];
            let time = lastPoint.time - firstPoint.time;
            let distance = lastPoint.position - firstPoint.position;
            return time ? distance / time : 0;
        },
        trackPoint: function () {
            let now = performance.now();
            this.trackingPoints.push({
                time: now,
                position: this.lastPosition
            });
            while (this.trackingPoints.length && now - this.trackingPoints[0].time > 100) {
                this.trackingPoints.shift();
            }
        },
        getPointerPosition: function (event) {
            return this.o.vertical ? event.pageY : event.pageX;
        },
        stopTracking: function () {
            this.pointerActive = false;
        },
        onChangeCurrentIndex: function (currentIndex) {
            if (this.currentIndex !== currentIndex) {
                this.currentIndex = currentIndex;
                this.updateClassnames();
                if (this.o.onChangeCurrentIndex) {
                    this.o.onChangeCurrentIndex.call(this, currentIndex);
                }
            }
        },
        updateClassnames: function () {
            for (let i = this.sliderLength; i--;) {
                let className = i === this.currentIndex ? "is-current" : (i === this.currentIndex - 1 || i === this.currentIndex + 1) ? "is-next" : "";
                this.msSlides[i].classList.remove("is-current", "is-next");
                if (className) {
                    this.msSlides[i].classList.add(className);
                }
            }
        }
    };

    function extend() {
        for (let i = 1; i < arguments.length; i++) {
            for (let key in arguments[i]) {
                arguments[0][key] = arguments[i][key];
            }
        }
        return arguments[0];
    }

    function wrapInLi(content) {
        return "<li>" + content + "</li>";
    }

    function getCurrentValue(values, progress, isForward) {
        if (typeof values === "string") {
            return values;
        } else if (Array.isArray(values)) {
            let value = isForward ? values[0] + progress * (values[1] - values[0]) : values[1] + progress * (values[0] - values[1]);
            return typeof values[0] === "number" ? value : value + "px";
        } else if (typeof values === "object") {
            let value = {};
            for (let key in values) {
                value[key] = getCurrentValue(values[key], progress, isForward);
            }
            return value;
        }
    }

    function supportsPassive() {
        let supportsPassive = false;
        try {
            let opts = Object.defineProperty({}, "passive", {
                get: function () {
                    supportsPassive = true;
                }
            });
            window.addEventListener("test", null, opts);
        } catch (e) {}
        return supportsPassive;
    }

    const transformProperty = (function () {
        let el = document.createElement("div");
        let props = ["transform", "WebkitTransform", "MozTransform", "msTransform", "OTransform"];
        for (let i = 0; i < props.length; i++) {
            if (el.style[props[i]] !== undefined) {
                return props[i];
            }
        }
        return "transform";
    })();

    return MomentumSlider;
}));
